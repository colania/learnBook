# 数据库索引

## InnoDB 的索引模型

每一个索引在 InnoDB 里面对应一棵 B+ 树.

<img src="https://static001.geekbang.org/resource/image/dc/8d/dcda101051f28502bd5c4402b292e38d.png" alt="img" style="zoom:50%;" />

主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。

非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。



### 基于主键索引和普通索引的查询有什么区别？

如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；

如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。

也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。



## 索引维护

#### 数据库为什么需要自增id

1. B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。如果新增的数据id在某个范围当中，需要逻辑上挪动后面的数据，空出位置。
2. 如果当前数据页已满，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。
3. 当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。
4. 主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。



## 覆盖索引

普通索引查询到id再回到主键索引树搜索的过程，我们称为回表。



如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。



由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。



## 最左前缀原则

这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。



## 索引下推

在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。

而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以<u>在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</u>

<img src="/Users/wwei/Library/Application Support/typora-user-images/image-20210419171448180.png" title="无索引下推" style="zoom:50%;" />



<img src="/Users/wwei/Library/Application Support/typora-user-images/image-20210419171537734.png" alt="索引下推" style="zoom:50%;" />

## 重建索引

索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。

但是，重建主键的过程不合理。不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ： alter table T engine=InnoDB。

